<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
    Copyright (C) 2006-2024 Carnegie Mellon University
    See license information in LICENSE.txt.
-->
<!--
    @DISTRIBUTION_STATEMENT_BEGIN@
    libfixbuf 2.5
    Copyright 2024 Carnegie Mellon University.
    NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
    INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
    UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR
    IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF
    FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS
    OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
    MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT,
    TRADEMARK, OR COPYRIGHT INFRINGEMENT.
    Licensed under a GNU-Lesser GPL 3.0-style license, please see
    LICENSE.txt or contact permission@sei.cmu.edu for full terms.
    [DISTRIBUTION STATEMENT A] This material has been approved for public
    release and unlimited distribution.  Please see Copyright notice for
    non-US Government use and distribution.
    This Software includes and/or makes use of Third-Party Software each
    subject to its own license.
    DM24-1020
    @DISTRIBUTION_STATEMENT_END@
-->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfixbuf: Connection-less Collector</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Connection-less Collector</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>How-To Use libfixbuf with a Data Buffer</p>
<p>To use fixbuf independent of the transport mode, the application must create an fbInfoModel_t using <a class="el" href="public_8h.html#a23b1973cadfc63b05fabe6091ce48875" title="Allocates a new information model.">fbInfoModelAlloc()</a> and any additional, vendor-specific information elements using <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Adds a single information element to an information model.">fbInfoModelAddElement()</a>, <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Adds multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>, <a class="el" href="public_8h.html#af72db51fd417df411a82909c5fd5d84d" title="Adds information specified in the given XML file to the information model.">fbInfoModelReadXMLFile()</a>, or <a class="el" href="public_8h.html#a2bbcf6d4a777ed7e0a2c364e0662b9f3" title="Adds information specified in the given XML data to the information model.">fbInfoModelReadXMLData()</a>. Next create an fbSession_t using <a class="el" href="public_8h.html#a19d0dfe113d61cdabf601ca79c3049c8" title="Allocates a transport session state container.">fbSessionAlloc()</a> and add internal templates via <a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8" title="Adds a template to a session.">fbSessionAddTemplate()</a>. The application will handle all connections and reading and simply pass fixbuf the buffer to be decoded. The buffer must contain valid IPFIX and should begin with the standard IPFIX header. Ideally, the application should provide the necessary templates before any data records to ensure that the application can decode all of the data records.</p>
<p>The application should NOT create an fbCollector. To create the fBuf, use <a class="el" href="public_8h.html#a4dcbc472c9fc394ecb23e1b6b2887894" title="Allocates a new buffer for collection.">fBufAllocForCollection()</a> and set the second parameter to NULL. The application then has everything needed to start reading from the IPFIX source. Ideally, the application will read the first 4 bytes of the message first to determine the length of the next IPFIX message. The first 2 bytes are the IPFIX version (0x000A) and the third and fourth bytes are the length of the following IPFIX message (including the IPFIX message header). The application should then continue reading the length of the IPFIX message into an allocated buffer. The buffer should then be set on the fBuf by calling <a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642" title="Sets a buffer on an fBuf for collection.">fBufSetBuffer()</a>. The application will continue to call <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> to receive the data records until <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> returns FALSE with error code FB_ERROR_BUFSZ. However, if the fBuf is in manual mode (see <a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1" title="Sets the automatic (read/write) mode flag on a buffer.">fBufSetAutomaticMode()</a>) AND the application was reading the message length, fixbuf will first return an FB_ERROR_EOM which will signal to the application to perform another read (if the application ignores FB_ERROR_EOM errors and calls <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a>, <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> will then return FB_ERROR_BUFSZ). This error notifies the application that there is not enough data in the buffer to read a full IPFIX message. If the application only read the size of the IPFIX message, the entire buffer should have been read. However, if the application was reading more than the IPFIX message length, additional data may remain in the buffer that belongs to the next IPFIX message. To determine how much data was left in the buffer unread, <a class="el" href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1" title="Retrieves the length of the buffer that is remaining after processing.">fBufRemaining()</a> will return the length of the buffer that was not processed. That remaining data should be copied to the beginning of the buffer and the remaining IPFIX message data should be read. After each read, the application needs to call <a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642" title="Sets a buffer on an fBuf for collection.">fBufSetBuffer()</a>. Note that <a class="el" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642" title="Sets a buffer on an fBuf for collection.">fBufSetBuffer()</a> sets the collector and exporter on the fBuf to NULL. The application should clear the FB_ERROR_BUFSZ and/or FB_ERROR_EOM error when they occur using g_clear_error().</p>
<p>fixbuf may return the following error codes if it encounters one of the below issues. The application should determine the error and respond appropriately.</p>
<ul>
<li>FB_ERROR_IPFIX<ul>
<li>If the first 2 bytes != 0x000A</li>
<li>If the length in the header &lt; 16</li>
</ul>
</li>
<li>FB_ERROR_EOM<ul>
<li>If the application read only the message length and the application called fBufSetAutomaticMode(fbuf, FALSE) (the fBuf is in manual mode). This means the remaining buffer length == 0 and the application should clear the error and perform another read</li>
</ul>
</li>
<li>FB_ERROR_BUFSZ<ul>
<li>If the header message length &gt; the given buffer length</li>
<li>if the given buffer == NULL</li>
<li>If the given buffer length &lt; 16</li>
<li>If buffer length == 0</li>
</ul>
</li>
</ul>
<p>Example usage: </p><div class="fragment"><div class="line">FILE *fp;</div>
<div class="line">uint8_t buf[65535];</div>
<div class="line">...</div>
<div class="line">while (fread(buf, 1, 4, fp) == 4) {</div>
<div class="line">   len = ntohs(*((uint16_t *)(buf+2)));</div>
<div class="line">   rc = fread(buf+4, 1, len-4, fp);</div>
<div class="line">   <span class="keywordflow">if</span> (rc &gt; 0) {</div>
<div class="line">       <a class="code hl_function" href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642">fBufSetBuffer</a>(fbuf, buf, rc+4);</div>
<div class="line">   } <span class="keywordflow">else</span> <span class="keywordflow">if</span> (feof(fp))</div>
<div class="line">   ....</div>
<div class="line">   <span class="keywordflow">for</span> (;;) {</div>
<div class="line">       ret = <a class="code hl_function" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7">fBufNext</a>(fbuf, (uint8_t *)rec, &amp;len, &amp;err);</div>
<div class="line">       <span class="keywordflow">if</span> (FALSE == ret) {</div>
<div class="line">          <span class="keywordflow">if</span> (g_error_matches(err, <a class="code hl_define" href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a>, <a class="code hl_define" href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a>)){</div>
<div class="line">             rem = <a class="code hl_function" href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1">fBufRemaining</a>(fbuf);</div>
<div class="line">             g_clear_error(&amp;err);</div>
<div class="line">             <span class="keywordflow">break</span>;</div>
<div class="line">          }</div>
<div class="line">       }</div>
<div class="line">    }</div>
<div class="line">}</div>
<div class="ttc" id="apublic_8h_html_a11c40f1d55e2d4b29b40eb4c07ce5ee7"><div class="ttname"><a href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7">fBufNext</a></div><div class="ttdeci">gboolean fBufNext(fBuf_t *fbuf, uint8_t *recbase, size_t *recsize, GError **err)</div><div class="ttdoc">Retrieves a record from a Buffer associated with a collecting process.</div></div>
<div class="ttc" id="apublic_8h_html_a16875886e559694c2a5d80cc1b9e00de"><div class="ttname"><a href="public_8h.html#a16875886e559694c2a5d80cc1b9e00de">FB_ERROR_DOMAIN</a></div><div class="ttdeci">#define FB_ERROR_DOMAIN</div><div class="ttdoc">All fixbuf errors are returned within the FB_ERROR_DOMAIN domain.</div><div class="ttdef"><b>Definition</b> public.h:1149</div></div>
<div class="ttc" id="apublic_8h_html_a28f24bbb227eb0f2fdd444c8754d9642"><div class="ttname"><a href="public_8h.html#a28f24bbb227eb0f2fdd444c8754d9642">fBufSetBuffer</a></div><div class="ttdeci">void fBufSetBuffer(fBuf_t *fbuf, uint8_t *buf, size_t buflen)</div><div class="ttdoc">Sets a buffer on an fBuf for collection.</div></div>
<div class="ttc" id="apublic_8h_html_a2e0ffd43c861a9833b279557d687c57a"><div class="ttname"><a href="public_8h.html#a2e0ffd43c861a9833b279557d687c57a">FB_ERROR_BUFSZ</a></div><div class="ttdeci">#define FB_ERROR_BUFSZ</div><div class="ttdoc">A message was received larger than the collector buffer size.</div><div class="ttdef"><b>Definition</b> public.h:1173</div></div>
<div class="ttc" id="apublic_8h_html_aee3090cf1b7d116077bb9b627d622fb1"><div class="ttname"><a href="public_8h.html#aee3090cf1b7d116077bb9b627d622fb1">fBufRemaining</a></div><div class="ttdeci">size_t fBufRemaining(fBuf_t *fbuf)</div><div class="ttdoc">Retrieves the length of the buffer that is remaining after processing.</div></div>
</div><!-- fragment --> </div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
