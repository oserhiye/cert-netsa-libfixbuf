<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<!--
    Copyright (C) 2006-2024 Carnegie Mellon University
    See license information in LICENSE.txt.
-->
<!--
    @DISTRIBUTION_STATEMENT_BEGIN@
    libfixbuf 2.5
    Copyright 2024 Carnegie Mellon University.
    NO WARRANTY. THIS CARNEGIE MELLON UNIVERSITY AND SOFTWARE ENGINEERING
    INSTITUTE MATERIAL IS FURNISHED ON AN "AS-IS" BASIS. CARNEGIE MELLON
    UNIVERSITY MAKES NO WARRANTIES OF ANY KIND, EITHER EXPRESSED OR
    IMPLIED, AS TO ANY MATTER INCLUDING, BUT NOT LIMITED TO, WARRANTY OF
    FITNESS FOR PURPOSE OR MERCHANTABILITY, EXCLUSIVITY, OR RESULTS
    OBTAINED FROM USE OF THE MATERIAL. CARNEGIE MELLON UNIVERSITY DOES NOT
    MAKE ANY WARRANTY OF ANY KIND WITH RESPECT TO FREEDOM FROM PATENT,
    TRADEMARK, OR COPYRIGHT INFRINGEMENT.
    Licensed under a GNU-Lesser GPL 3.0-style license, please see
    LICENSE.txt or contact permission@sei.cmu.edu for full terms.
    [DISTRIBUTION STATEMENT A] This material has been approved for public
    release and unlimited distribution.  Please see Copyright notice for
    non-US Government use and distribution.
    This Software includes and/or makes use of Third-Party Software each
    subject to its own license.
    DM24-1020
    @DISTRIBUTION_STATEMENT_END@
-->
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.11.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>libfixbuf: Network Collectors</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.11.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){ initResizable(false); });
/* @license-end */
</script>
</div><!-- top -->
<div id="doc-content">
<div><div class="header">
  <div class="headertitle"><div class="title">Network Collectors</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>How-To Listen Over the Network Using TCP (Recommended)</p>
<p>An additional type, <a class="el" href="public_8h.html#a4265eb950b491c405d075f1510a5710e">fbListener_t</a>, is used to build Collecting Processes to listen for connections from IPFIX Exporting Processes via the network. To use a listener, first create an fbInfoModel_t using <a class="el" href="public_8h.html#a23b1973cadfc63b05fabe6091ce48875" title="Allocates a new information model.">fbInfoModelAlloc()</a> and any additional, vendor-specific information elements using <a class="el" href="public_8h.html#ae06a524366afa6827d7e5abb1c33c0d0" title="Adds a single information element to an information model.">fbInfoModelAddElement()</a>, <a class="el" href="public_8h.html#a202bfa2340263229893a38de18670179" title="Adds multiple information elements in an array to an information model.">fbInfoModelAddElementArray()</a>, <a class="el" href="public_8h.html#af72db51fd417df411a82909c5fd5d84d" title="Adds information specified in the given XML file to the information model.">fbInfoModelReadXMLFile()</a>, or <a class="el" href="public_8h.html#a2bbcf6d4a777ed7e0a2c364e0662b9f3" title="Adds information specified in the given XML data to the information model.">fbInfoModelReadXMLData()</a>. Next create an fbSession_t using <a class="el" href="public_8h.html#a19d0dfe113d61cdabf601ca79c3049c8" title="Allocates a transport session state container.">fbSessionAlloc()</a> and add internal templates via <a class="el" href="public_8h.html#a2e4baf6d2142eca4cb526b1e80628bf8" title="Adds a template to a session.">fbSessionAddTemplate()</a>. Instead of maintaining state for a particular Transport Session, this fbSession_t instance will be used as a template for each Transport Session created by the listener.</p>
<p>Then create an fbListener_t to encapsulate a passive socket on the network to wait for connections from Exporting Processes using the <a class="el" href="public_8h.html#a9788e47d032ae69fbf99d8bef61ebfc7" title="Allocates a listener.">fbListenerAlloc()</a> call.</p>
<p>To wait for a connection from an Exporting Process, call <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a>, which handles the cloning of the fbSession_t, the creation of the fbCollector_t, and the creation of the buffer for reading from that collector, and returns the newly created fBuf_t instance.</p>
<p>A listener binds to each address returned by getaddrinfo(). Once a packet has been received, the collector will only read packets on the address it received the first packet UNLESS <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> is called again. If the application is expecting multiple connections or IPFIX records from multiple IPFIX (UDP) exporters, then the application should put the fBuf_t returned from <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> into to manual mode by calling <a class="el" href="public_8h.html#a661f4cc21e726345d3e22372af33c2d1" title="Sets the automatic (read/write) mode flag on a buffer.">fBufSetAutomaticMode()</a> with FALSE as the second argument and handle FB_ERROR_EOM errors returned from <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> by calling <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> again.</p>
<p>Each listener tracks every active collector/buffer (i.e., each active Session) it created; the <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> call will return an fBuf_t from which another IPFIX Message may be read if no new connections are available. The preferred parameter may be used to request an fBuf_t to try first, to minimize switching among available Sessions. See the documentation for <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a> for more details.</p>
<p>If an application wants to wait for connections on multiple ports or multiple transport protocols, the application can use <a class="el" href="public_8h.html#a4384bc78814aa74f85ed30c09b14c407" title="Accepts connections for multiple listeners.">fbListenerGroupWait()</a> to accept multiple connections. The application should create separate sessions and fbConnSpec_ts for each fbListener and call <a class="el" href="public_8h.html#a9788e47d032ae69fbf99d8bef61ebfc7" title="Allocates a listener.">fbListenerAlloc()</a> to allocate each listener. Create an fbListenerGroup_t by calling <a class="el" href="public_8h.html#afa82bcb623b0026d823bc7aba6a7610e" title="Allocates and returns an empty listenerGroup.">fbListenerGroupAlloc()</a> and add each listener to the group using <a class="el" href="public_8h.html#a5b5716c8fe63a2f982e32a98eed0e38f" title="Adds a previously allocated listener to the previously allocated group.">fbListenerGroupAddListener()</a>. Instead of calling <a class="el" href="public_8h.html#a68303972f3934cd1c7000486924af510" title="Waits on a listener.">fbListenerWait()</a>, use the function <a class="el" href="public_8h.html#a4384bc78814aa74f85ed30c09b14c407" title="Accepts connections for multiple listeners.">fbListenerGroupWait()</a> to listen on all addresses in the group. <a class="el" href="public_8h.html#a4384bc78814aa74f85ed30c09b14c407" title="Accepts connections for multiple listeners.">fbListenerGroupWait()</a> returns an fbListenerGroupResult_t which is a linked list of results. The fbListenerGroupResult_t contains a pointer to an fBuf_t and the fbListener_t that created the fBuf_t as well as a pointer to the next result, if available. Use <a class="el" href="public_8h.html#a620984c30070a7b3a1da81d1f84d798d" title="Frees the listener group result returned from fbListenerGroupWait().">fbListenerFreeGroupResult()</a> to free the result when <a class="el" href="public_8h.html#a11c40f1d55e2d4b29b40eb4c07ce5ee7" title="Retrieves a record from a Buffer associated with a collecting process.">fBufNext()</a> has been called on each fBuf_t.</p>
<p>The application could also use <a class="el" href="public_8h.html#a72f4ae91f7f0dc67a38eb5694be4605d" title="Waits for an incoming connection, just like fbListenerWait(), except that this function doesn&#39;t monit...">fbListenerWaitNoCollectors()</a> to handle only the initial accepting of a connection (for TCP). Once the application returns to <a class="el" href="public_8h.html#a72f4ae91f7f0dc67a38eb5694be4605d" title="Waits for an incoming connection, just like fbListenerWait(), except that this function doesn&#39;t monit...">fbListenerWaitNoCollectors()</a>, fixbuf will ignore that socket descriptor for the length of the connection.</p>
<p>Additionally, the application can use <a class="el" href="public_8h.html#ac9d2c94ddb32fa9ff187fdfe0e9358d9" title="Returns an fBuf wrapped around an independently managed socket and a properly created listener for TC...">fbListenerOwnSocketCollectorTCP()</a> to provide its own socket for listening instead of libfixbuf creating one for it.</p>
<p>To reject incoming connections, the application should use the <a class="el" href="public_8h.html#a4313f40737bf2a6ab1db94693119312c">fbListenerAppInit_fn</a> function callback. This will be called right after accept() is called (in the TCP case). The application can veto the connection by returning FALSE. Once the connection is vetoed, fixbuf will not listen on that socket descriptor. If the appinit() function should reject a connection the application should set the error code to FB_ERROR_NLREAD and the application should ignore FB_ERROR_NLREAD error codes. The appinit() function works slightly different for UDP. See the <a class="el" href="udp.html">UDP instructions</a> for how to use appinit() for collecting IPFIX over UDP. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</body>
</html>
